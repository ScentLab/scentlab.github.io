import './Results.svelte.css';
/* src/components/Results/Results.svelte generated by Svelte v3.32.3 */
import {
	SvelteComponent,
	append,
	attr,
	component_subscribe,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	handle_promise,
	init,
	insert,
	mount_component,
	noop,
	safe_not_equal,
	space,
	text,
	transition_in,
	transition_out
} from "../../../_snowpack/pkg/svelte/internal.js";

import { users } from "../../stores/index.js";
import { PC } from "../../utils/index.js";
import API from "../../api/perfumes.js";
import Title from "../Title/Title.svelte.js";
import MBTI from "../MBTI/MBTI.svelte.js";
import Perfumes from "../Perfumes/Perfumes.svelte.js";

function create_if_block(ctx) {
	let await_block_anchor;
	let promise;
	let current;

	let info = {
		ctx,
		current: null,
		token: null,
		hasCatch: false,
		pending: create_pending_block,
		then: create_then_block,
		catch: create_catch_block,
		value: 20,
		blocks: [,,,]
	};

	handle_promise(
		promise = /*getPerfumes*/ ctx[4]({
			matchStr: [.../*title*/ ctx[3].tags, .../*tags*/ ctx[1]].join(" "),
			filter: { gender: /*gender*/ ctx[2].tags }
		}),
		info
	);

	return {
		c() {
			await_block_anchor = empty();
			info.block.c();
		},
		m(target, anchor) {
			insert(target, await_block_anchor, anchor);
			info.block.m(target, info.anchor = anchor);
			info.mount = () => await_block_anchor.parentNode;
			info.anchor = await_block_anchor;
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			{
				const child_ctx = ctx.slice();
				child_ctx[20] = info.resolved;
				info.block.p(child_ctx, dirty);
			}
		},
		i(local) {
			if (current) return;
			transition_in(info.block);
			current = true;
		},
		o(local) {
			for (let i = 0; i < 3; i += 1) {
				const block = info.blocks[i];
				transition_out(block);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(await_block_anchor);
			info.block.d(detaching);
			info.token = null;
			info = null;
		}
	};
}

// (1:0) <script lang="ts">import { users }
function create_catch_block(ctx) {
	return {
		c: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};
}

// (45:6) {:then perfumes}
function create_then_block(ctx) {
	let title_1;
	let t0;
	let mbti_1;
	let t1;
	let perfumes;
	let current;

	title_1 = new Title({
			props: {
				title: /*title*/ ctx[3],
				descriptions: /*descriptions*/ ctx[0]
			}
		});

	mbti_1 = new MBTI({
			props: {
				descriptions: /*descriptions*/ ctx[0],
				tags: /*tags*/ ctx[1]
			}
		});

	perfumes = new Perfumes({
			props: {
				perfumes: /*perfumes*/ ctx[20].data.hits.hits
			}
		});

	return {
		c() {
			create_component(title_1.$$.fragment);
			t0 = space();
			create_component(mbti_1.$$.fragment);
			t1 = space();
			create_component(perfumes.$$.fragment);
		},
		m(target, anchor) {
			mount_component(title_1, target, anchor);
			insert(target, t0, anchor);
			mount_component(mbti_1, target, anchor);
			insert(target, t1, anchor);
			mount_component(perfumes, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(title_1.$$.fragment, local);
			transition_in(mbti_1.$$.fragment, local);
			transition_in(perfumes.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(title_1.$$.fragment, local);
			transition_out(mbti_1.$$.fragment, local);
			transition_out(perfumes.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(title_1, detaching);
			if (detaching) detach(t0);
			destroy_component(mbti_1, detaching);
			if (detaching) detach(t1);
			destroy_component(perfumes, detaching);
		}
	};
}

// (43:109)          Loading...       {:then perfumes}
function create_pending_block(ctx) {
	let t;

	return {
		c() {
			t = text("Loading...");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

function create_fragment(ctx) {
	let div1;
	let div0;
	let current;
	let if_block = /*title*/ ctx[3] && /*gender*/ ctx[2] && /*tags*/ ctx[1] && /*descriptions*/ ctx[0] && create_if_block(ctx);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			attr(div0, "class", "divide-y divide-purpick-100 svelte-z4vsbh");
			attr(div1, "class", " svelte-z4vsbh");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			if (if_block) if_block.m(div0, null);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*title*/ ctx[3] && /*gender*/ ctx[2] && /*tags*/ ctx[1] && /*descriptions*/ ctx[0]) if_block.p(ctx, dirty);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div1);
			if (if_block) if_block.d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $users;
	component_subscribe($$self, users, $$value => $$invalidate(5, $users = $$value));
	

	// import Gender from '../Gender/Gender.svelte'
	const getTagInStrArrLen = (a, t) => a.filter(s => s === t).length;

	const EL = getTagInStrArrLen($users.selects, "E");
	const IL = getTagInStrArrLen($users.selects, "I");
	const EnI = EL > IL ? "E" : "I";
	const SL = getTagInStrArrLen($users.selects, "S");
	const NL = getTagInStrArrLen($users.selects, "N");
	const SnN = SL > NL ? "S" : "N";
	const TL = getTagInStrArrLen($users.selects, "T");
	const FL = getTagInStrArrLen($users.selects, "F");
	const TnF = TL > FL ? "T" : "F";
	const JL = getTagInStrArrLen($users.selects, "J");
	const PL = getTagInStrArrLen($users.selects, "P");
	const JnP = JL > PL ? "J" : "P";
	const mbti = `${EnI}${SnN}${TnF}${JnP}`;
	const descriptions = PC.getDescription(mbti);
	const tags = PC.getTagsWithAttr(mbti);
	const gender = PC.getGender($users.selects.find(select => select === "MALE" || select === "FEMALE"));
	const title = PC.getTitle($users.selects.find(select => select === "sunrise" || select === "sunset"));

	const getPerfumes = async ({ matchStr, filter }) => {
		const perfumes = await API.getPerfumes({ matchStr, filter });

		return new Promise(resolve => {
				setTimeout(() => resolve(perfumes), 3000);
			});
	};

	return [descriptions, tags, gender, title, getPerfumes];
}

class Results extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default Results;